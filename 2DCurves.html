<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>s</title>
<link rel="icon" href="images/favicon.gif" type="image/x-icon"/>
<link rel="shortcut icon" href="images/favicon.gif" type="image/x-icon"/> 
<link rel="stylesheet" type="text/css" href="css/styles.css"/>
</head>

<script src="https://code.jquery.com/jquery-1.10.2.js"></script>

<body>
   <div class="bg">
    <!--start container-->
    <div id="container">
    <!--start header-->
    <header>
      <!--start logo-->
      <h1></h1>
      <h3></h3>
      <h1>GLSL Implicit Curves</h1>
      <!--end logo-->
      <!--start menu -->
  	   <nav>
         <ul>
         <li><h3></h3><input type="text" id="eText" value="y^2 - x^3 + x + 0.0025"><h3></h3></li>
         <li><h3></h3><button onclick="solve()">Draw!</button><h3></h3></li>
         <li><h3></h3><h4>Last update: 11.03.2015 </h4><h3></h3></li>
         </ul>
      </nav>
  	   <!--end menu-->
      <!--end header-->
	</header>
   <!--start intro-->
   <div class="holder_content">
   <div style=";width:auto;height:400px;background:#F9EECF;border:1px dotted black;text-align:center">
            <canvas id="canvas" width="100%" height="100%"></canvas>
          </div>
   </div>
   <!--end intro-->
   <!--start holder-->
   <div class="holder_content">
      <section class="group4">
        <h3>Controls</h3>
        <div id="user">
          <h4></h4>
          <label "=" for="inputZoom">viewport scale</label>
          <input id="inputZoom" type="number" value="1" step="0.01">
          <h4></h4>
        </div>
        
         <h3>Usage</h3>
         <font color="blue"><h3>^2,^3,(),+,-,*.</h3></font>
         <p> - use only x and y </p>
         <p> - use only ^3 or ^2: x^3, y^2, (x+2)^3 </p>
         <p> - xx don't work, use x*x instead </p>
         <p> - x2 don't work, use x^2 instead </p>
         <p> - any other symbol (a,b,...,z) is considered a constant </p>
         <p> - an user control is displayed for each constant </p> 
         <h4></h4>
         <h3>Log</h3>
         <p> - glsl rounding </p>
         <p> - controls <p>
         <p> - pan (mouse drag) and zoom (wheel) </p>
         <p> - added ^2 and ^3 </p>
       </section>
   </div>
   <!--end holder-->
   </div>
   <!--end container-->
   <!--start footer-->
   <footer>
      <div class="container">  
         <div id="FooterTwo"> CSS by <a href="http://www.marijazaric.com">marija zaric - creative simplicity</a> Â© 2011 Minimalism </div>
         <div id="FooterTree"></div> 
      </div>
   </footer>
   <!--end footer-->
   </div>
   <!--end bg-->
   <!-- Free template distributed by http://freehtml5templates.com -->
  </body>

<script src="js/Detector.js"></script>
          <script src="js/webgl-utils.js"></script>
          <script src="js/shader.js"></script>
          <script src="js/math.js"></script>
          <script src="js/iaparser.js"></script>

  <!-- TEXTURE VERTEX SHADER -->
<script type="x-shader/x-vertex" id="texture-vs">
attribute vec2 vpos;

varying vec2 texCoord;

void main()
{
  texCoord.x = (vpos.x+1.0)*0.5;
  texCoord.y = (vpos.y+1.0)*0.5;
  gl_Position = vec4(vpos.x, vpos.y, 0, 1);
}
</script>

<!-- TEXTURE FRAGMENT SHADER -->
<script type="x-shader/x-fragment" id="texture-fs">
precision mediump float;

varying vec2 texCoord;

uniform sampler2D tex;

void main() {
  gl_FragColor = texture2D(tex, texCoord);
}
</script>

<!-- IA VERTEX SHADER -->
<script type="x-shader/x-vertex" id="2dCurves-vs">
attribute vec2 vpos;

varying vec2 point;
varying vec2 texCoord;
varying vec2 worldSize;

uniform vec2 offset;
uniform vec2 ratio;
uniform float zoom;

void main()
{
  point = vpos*ratio*zoom + offset;
  worldSize = vec2(abs(vpos.x*ratio.x*zoom)*2.0,abs(vpos.y*ratio.y*zoom)*2.0);
  texCoord.x = (vpos.x+1.0)*0.5;
  texCoord.y = (vpos.y+1.0)*0.5;
  gl_Position = vec4(vpos.x, vpos.y, 0, 1);
}
</script>


<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="iaHeader-fs">
precision mediump float;

uniform float x0,y0;
uniform vec2 size;

varying vec2 point;
varying vec2 worldSize;

</script>

<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="ia-fs">

#define EPS 1.19e-07
#define INF (1.0/0.0)

float UP(float x){
  if(x < 0.0)
    return x*(1.0 - EPS);
  return x*(1.0 + EPS);
}

float DOWN(float x){
  if(x < 0.0)
    return x*(1.0 + EPS);
  return x*(1.0 - EPS);
}

#define Interval vec2

Interval Ineg(Interval x)
{
  return Interval(-x[1],-x[0]);
}

Interval Iadd(Interval x, Interval y)
{
  return Interval(DOWN(x[0] + y[0]), UP(x[1] + y[1]));
}

Interval Ishif(Interval x, float c)
{
  return Interval(DOWN(x[0] + c),UP(x[1] + c));
}

Interval Isub(Interval x, Interval y)
{
  return Interval(DOWN(x[0] - y[1]), UP(x[1] - y[0]));
}

Interval Iscale(Interval x, float c)
{
  if(c > 0.0)
    return Interval(DOWN(c*x[0]), UP(c*x[1]));
  if(c < 0.0)
    return Interval(DOWN(c*x[1]), UP(c*x[0]));
  return Interval(0.0,0.0);
}

Interval Imul(Interval x, Interval y)
{
  float mm=x[0]*y[0];
  float mM=x[0]*y[1];
  float Mm=x[1]*y[0];
  float MM=x[1]*y[1];
  return Interval(
    DOWN(min(min(min(mm,mM),Mm),MM)),
    UP(max(max(max(mm,mM),Mm),MM)));
}

Interval Iinv(Interval x)
{
  return Interval(DOWN(1.0/x[1]), UP(1.0/x[0]));
}

Interval Idiv(Interval x, Interval y)
{
  if(y[0] >= 0.0){
    if(x[0] >= 0.0)
      return Interval(DOWN(x[0]/y[1]),UP(x[1]/y[0]));
    if(x[1] <= 0.0)
      return Interval(DOWN(x[0]/y[0]),UP(x[1]/y[1]));
    return Interval(DOWN(x[0]/y[0]),UP(x[1]/y[0]));
  }
  else if(y[1] <= 0.0){
    if(x[0] >= 0.0)
      return Interval(DOWN(x[1]/y[1]),UP(x[0]/y[0]));
    if(x[1] <= 0.0)
      return Interval(DOWN(x[1]/y[0]),UP(x[0]/y[1]));
    return Interval(DOWN(x[1]/y[1]),UP(x[0]/y[1]));
  }  
  return Interval(-INF,INF);
}

Interval Isqrt(Interval x)
{
  if(x[0] <= 0.0)
    return Interval(0.0, UP(sqrt(x[1])));
  return Interval(DOWN(sqrt(x[0])),UP(sqrt(x[1])));
}

Interval Ilog(Interval x)
{
  if(x[0] <= 0.0)
    return Interval(-INF, UP(log(x[1])));
  return Interval(DOWN(log(x[0])),UP(x[1]));
}

Interval Iexp(Interval x)
{
  return Interval(DOWN(exp(x[0])),UP(exp(x[1])));
}

Interval Isqr(Interval x)
{
  if (x[0]>=0.0)
    return Interval(DOWN(x[0]*x[0]),UP(x[1]*x[1]));
  else if (x[1]<=0.0)
    return Interval(DOWN(x[1]*x[1]),UP(x[0]*x[0]));
  else
    return Interval(0.0,UP(max(x[0]*x[0],x[1]*x[1])));
}

Interval Icube(Interval x)
{
  return Interval(DOWN(x[0]*x[0]*x[0]),UP(x[1]*x[1]*x[1]));
}

Interval Ipow(Interval x, int p){
  if(p == 2)
    return Isqr(x);
  if(p == 3)
    return Icube(x);
  return x;
}

</script>


<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="iaFooter-fs">

void main()
{
  float x = point.x;
  float y = point.y;
  float w = 0.5*(worldSize.x/size.x);
  float h = 0.5*(worldSize.y/size.y);
  Interval v = F(x,y,w,h);
  if (v[0]>0.0)
    gl_FragColor=vec4(1.0,1.0,1.0,1.0);
  else if (v[1]<0.0)
    gl_FragColor=vec4(0.0,0.0,0.0,1.0);
  else
    gl_FragColor=vec4(1.0,0.0,0.0,1.0);
}
</script>

<script>

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

// mouse interactions
var mousePos;
var dragStart;
var dragging = false;
var pan = {x:0,y:0};
var zoom = 1.0;

// global variables
var canvas;
var gl;
var WIDTH = 400, HEIGHT = 400;
var curvesShader, texShader;

// expression constants
var constants = new Set();

var grid = {
  src: 0,
  dst: 1,
  w: WIDTH,
  h: HEIGHT,
  dx: 1.0,
  t: [],
  fbo: 0,
  swap: function() {
    var tmp = this.src;
    this.src = this.dst;
    this.dst = tmp;
  },
  print: function() {
         console.log("src " + this.src);
         console.log("dst " + this.dst);
         console.log("size " + this.w + "," + this.h); 
         console.log("dx " + this.dx);
         console.log("tex " + this.t[0] + " " + this.t[1]);
  },
  init: function(W, H) {
    this.w = W;
    this.h = H;

    fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

          for (var i = 0; i < 2; ++i) {
            var texture = gl.createTexture();
      this.t.push(texture);
            
      gl.bindTexture(gl.TEXTURE_2D, texture);

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.w, this.h, 0,
              gl.RGBA, gl.UNSIGNED_BYTE, null);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
          gl.TEXTURE_2D, this.t[i], 0);

      checkFB(fbo);
      gl.clear(gl.COLOR_BUFFER_BIT);
      }
  },
  enable: function() {
    gl.viewport(0, 0, this.w, this.h);
    
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
        gl.TEXTURE_2D, this.t[this.dst], 0);
    
  },
  disable: function(){
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
};

init();
render();

function updateUniforms(e){
  zoom = document.getElementById('inputZoom').value;
  curvesShader.start(gl);
    curvesShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    curvesShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    curvesShader.setUniform2f(gl, "offset", [pan.x,pan.y]);
    curvesShader.setUniform1f(gl, "zoom", zoom);
      constants.forEach(function(value) {
        curvesShader.setUniform1f(gl, value, document.getElementById('input' + value).value);
      });
  curvesShader.stop(gl);

  render();
}

function solve() {

  var fs =  document.getElementById("iaHeader-fs").text + "\n";

  constants = IAPARSER.parseConstants(document.getElementById("eText").value);
  constants.forEach(function(value) {
      fs += "uniform float " + value + ";\n";
  });

  $('#constants').remove();

  console.log(constants.size);
  
  fs += document.getElementById("ia-fs").text + "\n" + 
      IAPARSER.parse(document.getElementById("eText").value) +
      document.getElementById("iaFooter-fs").text;
  
  console.log(fs);
  curvesShader.loadText(gl, document.getElementById("2dCurves-vs").text, fs);
  curvesShader.start(gl);
    curvesShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    curvesShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    curvesShader.setUniform2f(gl, "offset", [pan.x,pan.y]);
    curvesShader.setUniform1f(gl, "zoom", zoom);
    if(constants.size > 0){
      var div = document.createElement("div");
      div.setAttribute("id", "constants");
      $('#user').prepend(div);

      constants.forEach(function(value) {

        var constantName = document.createElement
        var valueInput = document.createElement("INPUT");
        valueInput.setAttribute("id", "input" + value);
        valueInput.setAttribute("type", "number");
        valueInput.setAttribute("value", "1");
        valueInput.setAttribute("step", "0.0001");
        
        $('<div>').appendTo('#constants');
        $('<label for="input' + value + '"">' + value + '</label>').appendTo('#constants');
        $('#constants').append(valueInput);
        $('</div>').appendTo('#constants');

        $('#' + "input" + value).bind('keyup mouseup', updateUniforms);

        curvesShader.setUniform1f(gl, value, 1.0);
      });
    }
  curvesShader.stop(gl);

  render();
}

function init() {
  // Get A WebGL context
  canvas = document.getElementById("canvas");
    // Make it visually fill the positioned parent
  canvas.style.width ='100%';
  canvas.style.height='100%';
  // ...then set the internal size to match
  canvas.width  = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  
  HEIGHT = canvas.height;
  WIDTH = canvas.width;
  
  gl = getWebGLContext(canvas);
  if (!gl)
    return;
  $('#inputZoom').bind('keyup mouseup', updateUniforms);
  // MOUSE INTERACTIONS ----------------------------------------------------
  canvas.addEventListener('mousemove', function(evt) {
      if(dragging) {
        mousePos = getMousePos(canvas, evt);
        var offset = {};
        offset.x = ((mouseStart.x - mousePos.x)/WIDTH)*zoom; 
        offset.y = ((mouseStart.y - mousePos.y)/HEIGHT)*zoom; 
        curvesShader.start(gl);
        curvesShader.setUniform2f(gl, "offset", [pan.x + offset.x,pan.y + offset.y]);
        curvesShader.stop(gl);
        render();
        }
        }, false);

  canvas.addEventListener('mousedown', function(evt) {
      if(!dragging){
      dragging = true;
      mouseStart = getMousePos(canvas, evt);
      }
      }, false);
  
  canvas.addEventListener('mouseup', function(evt) {
      if(dragging){
        pan.x += ((mouseStart.x - mousePos.x)/WIDTH)*zoom; 
        pan.y += ((mouseStart.y - mousePos.y)/HEIGHT)*zoom; 
      }
      dragging = false;
      }, false);
  
  canvas.addEventListener('mousewheel', function(evt) {
        var wheel = event.wheelDelta/120;
        zoom += wheel/10;
        curvesShader.start(gl);
        curvesShader.setUniform1f(gl, "zoom", zoom);
        curvesShader.stop(gl);
        render();
      }, false);
  //------------------------------------------------------------------------


  // SHADER PROGRAMS -------------------------------------------------------
  texShader = new SHADER.Shader(gl, "texture-vs", "texture-fs");
  curvesShader = new SHADER.Shader(gl, "texture-vs", "texture-fs");
  //------------------------------------------------------------------------
  
  // TEXTURE BUFFER DATA ---------------------------------------------------
  var positionLocation = texShader.getLocation(gl, "vpos");
  var positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1.0, -1.0,
        3.0, -1.0,
        -1.0, 3.0]), gl.STATIC_DRAW);
  //------------------------------------------------------------------------
  
  grid.init(WIDTH, HEIGHT);

  solve();
}

function computeCurves() {
  grid.enable();
  curvesShader.start(gl);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  curvesShader.stop(gl);
  grid.disable();
}

function render() {
  computeCurves();
  gl.viewport(0, 0, WIDTH, HEIGHT);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, grid.t[grid.dst]);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  texShader.start(gl);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  texShader.stop(gl);
}

function checkFB(framebuffer) {
  if (!gl.isFramebuffer(framebuffer))
    throw("Invalid framebuffer");
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      switch (status) {
    case gl.FRAMEBUFFER_COMPLETE: break;
    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
      break;
    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            break;
    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            break;
    case gl.FRAMEBUFFER_UNSUPPORTED:
            throw("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
            break;
    default: throw("Incomplete framebuffer: " + status);
  }
}

function getMousePos(canvas, evt) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*canvas.width),
    y: Math.round((evt.clientY-rect.bottom)/(-rect.bottom+rect.top)*canvas.height)
  };
}

</script>
</html>
