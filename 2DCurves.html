<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>s</title>
<link rel="icon" href="images/favicon.gif" type="image/x-icon"/>
<link rel="shortcut icon" href="images/favicon.gif" type="image/x-icon"/> 
<link rel="stylesheet" type="text/css" href="css/styles.css"/>
</head>

<script src="js/jquery-1.10.2.js"></script>

<body>
   <div class="bg">
    <!--start container-->
    <div id="container">
    <!--start header-->
    <header>
      <!--start logo-->
      <h1></h1>
      <h3></h3>
      <h1>GLSL Implicit Curves</h1>
      <!--end logo-->
      <!--start menu -->
  	   <nav>
         <ul>
         <li><h3></h3><input type="text" id="eText" value="y^2 - x^3 + x + 0.0025"><h3></h3></li>
         <li><h3></h3><button onclick="solve()">Draw!</button><h3></h3></li>
         <li><h3></h3><h4>Last update: 11.03.2015 </h4><h3></h3></li>
         </ul>
      </nav>
  	   <!--end menu-->
      <!--end header-->
	</header>
   <!--start intro-->
   <div class="holder_content">
   <div style=";width:auto;height:400px;background:#F9EECF;border:1px dotted black;text-align:center">
            <canvas id="canvas" width="100%" height="100%"></canvas>
          </div>
   </div>
   <!--end intro-->
   <!--start holder-->
   <div class="holder_content">
      <section class="group4">
        <h3>Controls</h3>
        <div id="user">
          <h4></h4>
          <label "=" for="inputZoom">viewport scale</label>
          <input id="inputZoom" type="number" value="1" step="0.01">
          <h4>Anti-Aliasing</h4>
          <form action="">
            <input type="radio" name="anti-aliasing" value="none" onchange="render();" checked >none
            <input type="radio" name="anti-aliasing" value="fxaa" onchange="render();">FXAA
            <input type="radio" name="anti-aliasing" value="taubin" onchange="render();">Taubin<br>
          </form>
          <h4></h4>
        </div>
        
        <h3>Functions</h3>
        <button type="button" onclick="setFunction('0.004 +0.110*x -0.177*y -0.174*x*x +0.224*x*y -0.303*y*y -0.168*x*x*x +0.327*x*x*y -0.087*x*y*y -0.013*y*y*y +0.235*x*x*x*x -0.667*x*x*x*y +0.745*x*x*y*y -0.029*x*y*y*y +0.072*y*y*y*y')">Taubin</button>
        <button type="button" onclick="setFunction('y^2 - x^3 + x + 0.0025')">Cubic</button>
         <h3>Usage</h3>
         <font color="blue"><h3>^2,^3,(),+,-,*.</h3></font>
         <p> - use only x and y </p>
         <p> - use only ^3 or ^2: x^3, y^2, (x+2)^3 </p>
         <p> - xx don't work, use x*x instead </p>
         <p> - x2 don't work, use x^2 instead </p>
         <p> - any other symbol (a,b,...,z) is considered a constant </p>
         <p> - an user control is displayed for each constant </p> 
         <h4></h4>
         <h3>Log</h3>
         <p> - glsl rounding </p>
         <p> - controls <p>
         <p> - pan (mouse drag) and zoom (wheel) </p>
         <p> - added ^2 and ^3 </p>
       </section>
   </div>
   <!--end holder-->
   </div>
   <!--end container-->
   <!--start footer-->
   <footer>
      <div class="container">  
         <div id="FooterTwo"> CSS by <a href="http://www.marijazaric.com">marija zaric - creative simplicity</a> Â© 2011 Minimalism </div>
         <div id="FooterTree"></div> 
      </div>
   </footer>
   <!--end footer-->
   </div>
   <!--end bg-->
   <!-- Free template distributed by http://freehtml5templates.com -->
  </body>

<script src="js/Detector.js"></script>
<script src="js/webgl-utils.js"></script>
<script src="js/shader.js"></script>
<script src="js/math.js"></script>
<script src="js/iaparser.js"></script>
<script src="js/fparser.js"></script>

  <!-- TEXTURE VERTEX SHADER -->
<script type="x-shader/x-vertex" id="texture-vs">
attribute vec2 vpos;

varying vec2 texCoord;

void main()
{
  texCoord.x = (vpos.x+1.0)*0.5;
  texCoord.y = (vpos.y+1.0)*0.5;
  gl_Position = vec4(vpos.x, vpos.y, 0, 1);
}
</script>

<!-- TEXTURE FRAGMENT SHADER -->
<script type="x-shader/x-fragment" id="texture-fs">
precision mediump float;

varying vec2 texCoord;

uniform sampler2D tex;

void main() {
  gl_FragColor = texture2D(tex, texCoord);
}
</script>

<!-- TAUBIN VERTEX SHADER -->
<script type="x-shader/x-vertex" id="taubin-vs">
attribute vec2 vpos;

varying vec2 point;
varying vec2 texCoord;
varying vec2 worldSize;

uniform vec2 offset;
uniform vec2 ratio;
uniform float zoom;

void main()
{
  point = vpos*ratio*zoom + offset;
  worldSize = vec2(abs(vpos.x*ratio.x*zoom)*2.0,abs(vpos.y*ratio.y*zoom)*2.0);
  texCoord.x = (vpos.x+1.0)*0.5;
  texCoord.y = (vpos.y+1.0)*0.5;
  gl_Position = vec4(vpos.x, vpos.y, 0, 1);
}
</script>

<!-- TAUBIN FRAGMENT SHADER -->
<script type="x-shader/x-fragment" id="taubinHeader-fs">
precision mediump float;

uniform vec2 size;

varying vec2 point;
varying vec2 worldSize;
</script>

<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="taubinFooter-fs">

void main()
{
  float x = point.x;
  float y = point.y;
  float v = F(x,y);
  
  float w = 0.5*(worldSize.x/size.x);
  float h = 0.5*(worldSize.y/size.y);

  vec2 g = vec2((F(x+w,y) - F(x-w,y))/(2.0*w),(F(x,y+h) - F(x,y-h))/(2.0*h));
  vec2 p = vec2(x,y);
  //vec2 g = vec2(dFdx(x),dFdy(y));
  v = v/length(g);
  float W = 2.0*w;
  gl_FragColor = vec4(0.0,0.0,0.0,1.0-smoothstep(-W,W,v));
  if(v > 0.0)
    gl_FragColor = vec4(1.0,0.0,0.0,1.0);
  else gl_FragColor = vec4(0.0,0.0,1.0,1.0);
}
</script>

<!-- TEXTURE VERTEX SHADER -->
<script type="x-shader/x-vertex" id="fxaa-vs">
attribute vec2 vpos;

varying vec4 posPos;

uniform float FXAA_SUBPIX_SHIFT; // = 1.0/4.0;
uniform float rt_w; // GeeXLab built-in
uniform float rt_h; // GeeXLab built-in

void main(void)
{
  vec2 texCoord = vec2((vpos.x+1.0)*0.5, (vpos.y+1.0)*0.5);
  vec2 rcpFrame = vec2(1.0/rt_w, 1.0/rt_h);
  
  posPos.xy = texCoord;
  posPos.zw = texCoord - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT));

  gl_Position = vec4(vpos.x, vpos.y, 0, 1);
}
</script>

<!-- TEXTURE FRAGMENT SHADER -->
<script type="x-shader/x-fragment" id="fxaa-fs">
precision mediump float;

uniform sampler2D tex0; // 0
uniform float vx_offset;
uniform float rt_w; // GeeXLab built-in
uniform float rt_h; // GeeXLab built-in
uniform float FXAA_SPAN_MAX;// = 8.0;
uniform float FXAA_REDUCE_MUL;// = 1.0/8.0;
varying vec4 posPos;

#define FxaaInt2 ivec2
#define FxaaFloat2 vec2
#define FxaaTexLod0(t, p) texture2D(t, p)

vec4 FxaaTexOff(sampler2D t, vec2 p, ivec2 o, vec2 r){
  vec2 T = gl_FragCoord.xy;
  vec2 P = vec2(T.x + float(o.x), T.y + float(o.y));
  return texture2D(t, vec2(P.x*r.x, P.y*r.y));
}

vec3 FxaaPixelShader( 
  vec4 posPos, // Output of FxaaVertexShader interpolated across screen.
  sampler2D tex, // Input texture.
  vec2 rcpFrame) // Constant {1.0/frameWidth, 1.0/frameHeight}.
{   
/*---------------------------------------------------------*/
    #define FXAA_REDUCE_MIN   (1.0/128.0)
    //#define FXAA_REDUCE_MUL   (1.0/8.0)
    //#define FXAA_SPAN_MAX     8.0
/*---------------------------------------------------------*/
    vec3 rgbNW = FxaaTexLod0(tex, posPos.zw).xyz;
    vec3 rgbNE = FxaaTexOff(tex, posPos.zw, FxaaInt2(1,0), rcpFrame.xy).xyz;
    vec3 rgbSW = FxaaTexOff(tex, posPos.zw, FxaaInt2(0,1), rcpFrame.xy).xyz;
    vec3 rgbSE = FxaaTexOff(tex, posPos.zw, FxaaInt2(1,1), rcpFrame.xy).xyz;
    vec3 rgbM  = FxaaTexLod0(tex, posPos.xy).xyz;
/*---------------------------------------------------------*/
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
/*---------------------------------------------------------*/
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
/*---------------------------------------------------------*/
    vec2 dir; 
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
/*---------------------------------------------------------*/
    float dirReduce = max(
        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),
        FXAA_REDUCE_MIN);
    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(FxaaFloat2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX), 
          max(FxaaFloat2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), 
          dir * rcpDirMin)) * rcpFrame.xy;
/*--------------------------------------------------------*/
    vec3 rgbA = (1.0/2.0) * (
        FxaaTexLod0(tex, posPos.xy + dir * (1.0/3.0 - 0.5)).xyz +
        FxaaTexLod0(tex, posPos.xy + dir * (2.0/3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (
        FxaaTexLod0(tex, posPos.xy + dir * (0.0/3.0 - 0.5)).xyz +
        FxaaTexLod0(tex, posPos.xy + dir * (3.0/3.0 - 0.5)).xyz);
    float lumaB = dot(rgbB, luma);
    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;
    return rgbB; }

vec4 PostFX(sampler2D tex, vec2 uv, float time)
{
  vec4 c = vec4(0.0);
  vec2 rcpFrame = vec2(1.0/rt_w, 1.0/rt_h);
  c.rgb = FxaaPixelShader(posPos, tex, rcpFrame);
  //c.rgb = 1.0 - texture2D(tex, posPos.xy).rgb;
  c.a = 1.0;
  return c;
}
    
void main() 
{ 
  vec2 uv = posPos.xy;//gl_TexCoord[0].st;
  gl_FragColor = PostFX(tex0, uv, 0.0);
}

</script>

<!-- IA VERTEX SHADER -->
<script type="x-shader/x-vertex" id="2dCurves-vs">
attribute vec2 vpos;

varying vec2 point;
varying vec2 texCoord;
varying vec2 worldSize;

uniform vec2 offset;
uniform vec2 ratio;
uniform float zoom;

void main()
{
  point = vpos*ratio*zoom + offset;
  worldSize = vec2(abs(vpos.x*ratio.x*zoom)*2.0,abs(vpos.y*ratio.y*zoom)*2.0);
  texCoord.x = (vpos.x+1.0)*0.5;
  texCoord.y = (vpos.y+1.0)*0.5;
  gl_Position = vec4(vpos.x, vpos.y, 0, 1);
}
</script>


<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="iaHeader-fs">
precision mediump float;

uniform float x0,y0;
uniform vec2 size;

varying vec2 point;
varying vec2 worldSize;

</script>

<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="ia-fs">

#define EPS 1.19e-07
#define INF (1.0/0.0)

float UP(float x){
  if(x < 0.0)
    return x*(1.0 - EPS);
  return x*(1.0 + EPS);
}

float DOWN(float x){
  if(x < 0.0)
    return x*(1.0 + EPS);
  return x*(1.0 - EPS);
}

#define Interval vec2

Interval Ineg(Interval x)
{
  return Interval(-x[1],-x[0]);
}

Interval Iadd(Interval x, Interval y)
{
  return Interval(DOWN(x[0] + y[0]), UP(x[1] + y[1]));
}

Interval Ishif(Interval x, float c)
{
  return Interval(DOWN(x[0] + c),UP(x[1] + c));
}

Interval Isub(Interval x, Interval y)
{
  return Interval(DOWN(x[0] - y[1]), UP(x[1] - y[0]));
}

Interval Iscale(Interval x, float c)
{
  if(c > 0.0)
    return Interval(DOWN(c*x[0]), UP(c*x[1]));
  if(c < 0.0)
    return Interval(DOWN(c*x[1]), UP(c*x[0]));
  return Interval(0.0,0.0);
}

Interval Imul(Interval x, Interval y)
{
  float mm=x[0]*y[0];
  float mM=x[0]*y[1];
  float Mm=x[1]*y[0];
  float MM=x[1]*y[1];
  return Interval(
    DOWN(min(min(min(mm,mM),Mm),MM)),
    UP(max(max(max(mm,mM),Mm),MM)));
}

Interval Iinv(Interval x)
{
  return Interval(DOWN(1.0/x[1]), UP(1.0/x[0]));
}

Interval Idiv(Interval x, Interval y)
{
  if(y[0] >= 0.0){
    if(x[0] >= 0.0)
      return Interval(DOWN(x[0]/y[1]),UP(x[1]/y[0]));
    if(x[1] <= 0.0)
      return Interval(DOWN(x[0]/y[0]),UP(x[1]/y[1]));
    return Interval(DOWN(x[0]/y[0]),UP(x[1]/y[0]));
  }
  else if(y[1] <= 0.0){
    if(x[0] >= 0.0)
      return Interval(DOWN(x[1]/y[1]),UP(x[0]/y[0]));
    if(x[1] <= 0.0)
      return Interval(DOWN(x[1]/y[0]),UP(x[0]/y[1]));
    return Interval(DOWN(x[1]/y[1]),UP(x[0]/y[1]));
  }  
  return Interval(-INF,INF);
}

Interval Isqrt(Interval x)
{
  if(x[0] <= 0.0)
    return Interval(0.0, UP(sqrt(x[1])));
  return Interval(DOWN(sqrt(x[0])),UP(sqrt(x[1])));
}

Interval Ilog(Interval x)
{
  if(x[0] <= 0.0)
    return Interval(-INF, UP(log(x[1])));
  return Interval(DOWN(log(x[0])),UP(x[1]));
}

Interval Iexp(Interval x)
{
  return Interval(DOWN(exp(x[0])),UP(exp(x[1])));
}

Interval Isqr(Interval x)
{
  if (x[0]>=0.0)
    return Interval(DOWN(x[0]*x[0]),UP(x[1]*x[1]));
  else if (x[1]<=0.0)
    return Interval(DOWN(x[1]*x[1]),UP(x[0]*x[0]));
  else
    return Interval(0.0,UP(max(x[0]*x[0],x[1]*x[1])));
}

Interval Icube(Interval x)
{
  return Interval(DOWN(x[0]*x[0]*x[0]),UP(x[1]*x[1]*x[1]));
}

Interval Ipow(Interval x, int p){
  if(p == 2)
    return Isqr(x);
  if(p == 3)
    return Icube(x);
  return x;
}

</script>


<!-- IA FRAGMENT SHADER HEADER -->
<script type="x-shader/x-fragment" id="iaFooter-fs">

void main()
{
  float x = point.x;
  float y = point.y;
  float w = 0.5*(worldSize.x/size.x);
  float h = 0.5*(worldSize.y/size.y);
  Interval v = F(x,y,w,h);
  if (v[0]>0.0)
    gl_FragColor=vec4(1.0,1.0,1.0,1.0);
  else if (v[1]<0.0)
    gl_FragColor=vec4(0.0,0.0,0.0,1.0);
  else
    gl_FragColor=vec4(1.0,0.0,0.0,1.0);
}
</script>

<script>
  
$.get("/ClothSimulation.html", function(data){
  alert("Data: " + data);
});

function readFile(filename){
  console.log(filename);
  $.get(filename, function(data){console.log("EITA\n"); console.log(data);});
}

readFile("/2dCurves/taubin.vs");

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

// mouse interactions
var mousePos;
var dragStart;
var dragging = false;
var pan = {x:0,y:0};
var curPan = {x:0,y:0};
var zoom = 1.0;

// global variables
var canvas;
var gl;
var WIDTH = 400, HEIGHT = 400;
var curvesShader, texShader, fxaaShader, taubinShader;

// expression constants
var constants = new Set();

var grid = {
  src: 0,
  dst: 1,
  w: WIDTH,
  h: HEIGHT,
  dx: 1.0,
  t: [],
  fbo: 0,
  swap: function() {
    var tmp = this.src;
    this.src = this.dst;
    this.dst = tmp;
  },
  print: function() {
         console.log("src " + this.src);
         console.log("dst " + this.dst);
         console.log("size " + this.w + "," + this.h); 
         console.log("dx " + this.dx);
         console.log("tex " + this.t[0] + " " + this.t[1]);
  },
  init: function(W, H) {
    this.w = W;
    this.h = H;

    fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

          for (var i = 0; i < 2; ++i) {
            var texture = gl.createTexture();
      this.t.push(texture);
            
      gl.bindTexture(gl.TEXTURE_2D, texture);

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.w, this.h, 0,
              gl.RGBA, gl.UNSIGNED_BYTE, null);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
          gl.TEXTURE_2D, this.t[i], 0);

      checkFB(fbo);
      gl.clear(gl.COLOR_BUFFER_BIT);
      }
  },
  enable: function() {
    gl.viewport(0, 0, this.w, this.h);
    
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
        gl.TEXTURE_2D, this.t[this.dst], 0);
    
  },
  disable: function(){
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
};

//init();
//render();

function updateUniforms(e){
  zoom = document.getElementById('inputZoom').value;
  curvesShader.start(gl);
    curvesShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    curvesShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    curvesShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    curvesShader.setUniform1f(gl, "zoom", zoom);
      constants.forEach(function(value) {
        curvesShader.setUniform1f(gl, value, document.getElementById('input' + value).value);
      });
  curvesShader.stop(gl);

  taubinShader.start(gl);
    taubinShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    taubinShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    taubinShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    taubinShader.setUniform1f(gl, "zoom", zoom);
      constants.forEach(function(value) {
        taubinShader.setUniform1f(gl, value, document.getElementById('input' + value).value);
      });
  taubinShader.stop(gl);

  render();
}

function solve() {

  //var fs =  document.getElementById("iaHeader-fs").text + "\n";
  var fs = readFile("2dCurves/iaHeader.fs") + "\n";

  constants = IAPARSER.parseConstants(document.getElementById("eText").value);
  constants.forEach(function(value) {
      fs += "uniform float " + value + ";\n";
  });

  $('#constants').remove();

  console.log(constants.size);
  
//  fs += document.getElementById("ia-fs").text + "\n" + 
//      IAPARSER.parse(document.getElementById("eText").value) +
//      document.getElementById("iaFooter-fs").text;

  fs += readFile("2dCurves/ia.fs") + "\n" + 
      IAPARSER.parse(document.getElementById("eText").value) +
      readFile("2dCurves/iaFooter.fs");
        
  console.log(fs);
//  curvesShader.loadText(gl, document.getElementById("2dCurves-vs").text, fs);
  curvesShader.loadText(gl, readFile("2dCurves/2dCurves.vs"), fs);
  curvesShader.start(gl);
    curvesShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    curvesShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    curvesShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    curvesShader.setUniform1f(gl, "zoom", zoom);
    if(constants.size > 0){
      var div = document.createElement("div");
      div.setAttribute("id", "constants");
      $('#user').prepend(div);

      constants.forEach(function(value) {

        var constantName = document.createElement
        var valueInput = document.createElement("INPUT");
        valueInput.setAttribute("id", "input" + value);
        valueInput.setAttribute("type", "number");
        valueInput.setAttribute("value", "1");
        valueInput.setAttribute("step", "0.0001");
        
        $('<div>').appendTo('#constants');
        $('<label for="input' + value + '"">' + value + '</label>').appendTo('#constants');
        $('#constants').append(valueInput);
        $('</div>').appendTo('#constants');

        $('#' + "input" + value).bind('keyup mouseup', updateUniforms);

        curvesShader.setUniform1f(gl, value, 1.0);
      });
    }
  curvesShader.stop(gl);

  solveFloat();

  render();
}

function solveFloat() {
  //var fs =  document.getElementById("taubinHeader-fs").text + "\n";
  var fs =  readFile("2dCurves/taubinHeader.fs").text + "\n";

  constants.forEach(function(value) {
      fs += "uniform float " + value + ";\n";
  });
  
  fs += FPARSER.parse(document.getElementById("eText").value) +
  //    document.getElementById("taubinFooter-fs").text;
      readFile("2dCurves/taubinFooter.fs");
  
  console.log(fs);
//  taubinShader.loadText(gl, document.getElementById("taubin-vs").text, fs);
  taubinShader.loadText(gl, readFile("2dCurves/taubin.vs"), fs);
  taubinShader.start(gl);
    taubinShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    taubinShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    taubinShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    taubinShader.setUniform1f(gl, "zoom", zoom);
    if(constants.size > 0){
      constants.forEach(function(value) {
        taubinShader.setUniform1f(gl, value, 1.0);
      });
    }
  taubinShader.stop(gl);
}

function setFunction(e) {
  document.getElementById("eText").value = e;
  solve();
}

function init() {
  // Get A WebGL context
  canvas = document.getElementById("canvas");
    // Make it visually fill the positioned parent
  canvas.style.width ='100%';
  canvas.style.height='100%';
  // ...then set the internal size to match
  canvas.width  = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  
  HEIGHT = canvas.height;
  WIDTH = canvas.width;
  
  gl = getWebGLContext(canvas);
  if (!gl)
    return;
  $('#inputZoom').bind('keyup mouseup', updateUniforms);
  // MOUSE INTERACTIONS ----------------------------------------------------
  canvas.addEventListener('mousemove', function(evt) {
      if(dragging) {
        mousePos = getMousePos(canvas, evt);
        var offset = {};
        offset.x = ((mouseStart.x - mousePos.x)/WIDTH)*zoom; 
        offset.y = ((mouseStart.y - mousePos.y)/HEIGHT)*zoom; 
        curPan.x = pan.x + offset.x;
        curPan.y = pan.y + offset.y;
        //curvesShader.start(gl);
        //  curvesShader.setUniform2f(gl, "offset", [pan.x + offset.x,pan.y + offset.y]);
        //curvesShader.stop(gl);
        updateUniforms();
        render();
        }
        }, false);

  canvas.addEventListener('mousedown', function(evt) {
      if(!dragging){
      dragging = true;
      mouseStart = getMousePos(canvas, evt);
      }
      }, false);
  
  canvas.addEventListener('mouseup', function(evt) {
      if(dragging){
        pan.x += ((mouseStart.x - mousePos.x)/WIDTH)*zoom; 
        pan.y += ((mouseStart.y - mousePos.y)/HEIGHT)*zoom; 
        curPan.x = pan.x;
        curPan.y = pan.y;
      }
      dragging = false;
      }, false);
  
  canvas.addEventListener('mousewheel', function(evt) {
        var wheel = event.wheelDelta/120;
        zoom += wheel/10;
        updateUniforms();
        //curvesShader.start(gl);
        //curvesShader.setUniform1f(gl, "zoom", zoom);
        //curvesShader.stop(gl);
        render();
      }, false);
  //------------------------------------------------------------------------


  // SHADER PROGRAMS -------------------------------------------------------
  //texShader = new SHADER.Shader(gl, "texture-vs", "texture-fs");
  //curvesShader = new SHADER.Shader(gl, "texture-vs", "texture-fs");
  //taubinShader = new SHADER.Shader(gl, "texture-vs", "texture-fs");
  //fxaaShader = new SHADER.Shader(gl, "fxaa-vs", "fxaa-fs");
  texShader = new SHADER.ShaderFromFile(gl, readFile("2dCruves/texture-vs"), readFile("2dCruves/texture-fs"));
  curvesShader = new SHADER.ShaderFromFile(gl, readFile("2dCruves/texture-vs"), readFile("2dCruves/texture-fs"));
  taubinShader = new SHADER.ShaderFromFile(gl, readFile("2dCruves/texture-vs"), readFile("2dCruves/texture-fs"));
  fxaaShader = new SHADER.ShaderFromFile(gl, readFile("2dCruves/fxaa-vs"), readFile("2dCruves/fxaa-fs"));
  fxaaShader.start(gl);
    fxaaShader.setUniform1f(gl, "FXAA_SPAN_MAX", 8.0);
    fxaaShader.setUniform1f(gl, "FXAA_REDUCE_MUL", 1.0/8.0);
    fxaaShader.setUniform1f(gl, "FXAA_SUBPIX_SHIFT", 1.0/4.0);
    fxaaShader.setUniform1f(gl, "rt_w", WIDTH);
    fxaaShader.setUniform1f(gl, "rt_h", HEIGHT);
  fxaaShader.stop(gl);
  //------------------------------------------------------------------------
  
  // TEXTURE BUFFER DATA ---------------------------------------------------
  var positionLocation = texShader.getLocation(gl, "vpos");
  var positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1.0, -1.0,
        3.0, -1.0,
        -1.0, 3.0]), gl.STATIC_DRAW);
  //------------------------------------------------------------------------
  
  grid.init(WIDTH, HEIGHT);

  solve();
}

function computeCurves() {
  grid.enable();
  curvesShader.start(gl);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  curvesShader.stop(gl);
  grid.disable();
}

function render() {
  computeCurves();

  gl.viewport(0, 0, WIDTH, HEIGHT);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, grid.t[grid.dst]);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  var radios = document.getElementsByName('anti-aliasing');
  var selected = "none";
  for (var i = 0, length = radios.length; i < length; i++) {
    if (radios[i].checked) {
        selected = radios[i].value;
        break;
    }
  }
  
  if(selected == "fxaa"){
    fxaaShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    fxaaShader.stop(gl);
  }
  else if(selected == "taubin"){
    taubinShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    taubinShader.stop(gl);
  }
  else {
    texShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    texShader.stop(gl);
  }
}

function checkFB(framebuffer) {
  if (!gl.isFramebuffer(framebuffer))
    throw("Invalid framebuffer");
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      switch (status) {
    case gl.FRAMEBUFFER_COMPLETE: break;
    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
      break;
    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            break;
    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            break;
    case gl.FRAMEBUFFER_UNSUPPORTED:
            throw("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
            break;
    default: throw("Incomplete framebuffer: " + status);
  }
}

function getMousePos(canvas, evt) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*canvas.width),
    y: Math.round((evt.clientY-rect.bottom)/(-rect.bottom+rect.top)*canvas.height)
  };
}

</script>
</html>
