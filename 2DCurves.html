<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>s</title>
<link rel="icon" href="images/favicon.gif" type="image/x-icon"/>
<link rel="shortcut icon" href="images/favicon.gif" type="image/x-icon"/> 
<link rel="stylesheet" type="text/css" href="css/styles.css"/>
</head>

<script src="js/jquery-1.10.2.js"></script>

<body>
   <div class="bg">
    <!--start container-->
    <div id="container">
    <!--start header-->
    <header>
      <!--start logo-->
      <h1></h1>
      <h3></h3>
      <h1>GLSL Implicit Curves</h1>
      <!--end logo-->
      <!--start menu -->
  	   <nav>
         <ul>
         <li><h3></h3><input type="text" id="eText" value="y^2 - x^3 + x + 0.0025"><h3></h3></li>
         <li><h3></h3><button onclick="solve()">Draw!</button><h3></h3></li>
         <li><h3></h3><h4>Last update: 11.03.2015 </h4><h3></h3></li>
         </ul>
      </nav>
  	   <!--end menu-->
      <!--end header-->
	</header>
   <!--start intro-->
   <div class="holder_content">
   <div style=";width:auto;height:400px;background:#F9EECF;border:1px dotted black;text-align:center">
            <canvas id="canvas" width="100%" height="100%"></canvas>
          </div>
   </div>
   <!--end intro-->
   <!--start holder-->
   <div class="holder_content">
      <section class="group4">
        <h3>Controls</h3>
        <div id="user">
          <h4></h4>
          <label "=" for="inputZoom">viewport scale</label>
          <input id="inputZoom" type="number" value="1" step="0.01">
          <h4>Anti-Aliasing</h4>
          <form action="">
            <input type="radio" name="anti-aliasing" value="none" onchange="render();" checked >none
            <input type="radio" name="anti-aliasing" value="fxaa" onchange="render();">FXAA
            <input type="radio" name="anti-aliasing" value="taubin" onchange="render();">Taubin<br>
          </form>
          <h4></h4>
        </div>
        
        <h3>Functions</h3>
        <button type="button" onclick="setFunction('0.004 +0.110*x -0.177*y -0.174*x*x +0.224*x*y -0.303*y*y -0.168*x*x*x +0.327*x*x*y -0.087*x*y*y -0.013*y*y*y +0.235*x*x*x*x -0.667*x*x*x*y +0.745*x*x*y*y -0.029*x*y*y*y +0.072*y*y*y*y')">Taubin</button>
        <button type="button" onclick="setFunction('y^2 - x^3 + x + 0.0025')">Cubic</button>
         <h3>Usage</h3>
         <font color="blue"><h3>^2,^3,(),+,-,*.</h3></font>
         <p> - use only x and y </p>
         <p> - use only ^3 or ^2: x^3, y^2, (x+2)^3 </p>
         <p> - xx don't work, use x*x instead </p>
         <p> - x2 don't work, use x^2 instead </p>
         <p> - any other symbol (a,b,...,z) is considered a constant </p>
         <p> - an user control is displayed for each constant </p> 
         <h4></h4>
         <h3>Log</h3>
         <p> - glsl rounding </p>
         <p> - controls <p>
         <p> - pan (mouse drag) and zoom (wheel) </p>
         <p> - added ^2 and ^3 </p>
       </section>
   </div>
   <!--end holder-->
   </div>
   <!--end container-->
   <!--start footer-->
   <footer>
      <div class="container">  
         <div id="FooterTwo"> CSS by <a href="http://www.marijazaric.com">marija zaric - creative simplicity</a> Â© 2011 Minimalism </div>
         <div id="FooterTree"></div> 
      </div>
   </footer>
   <!--end footer-->
   </div>
   <!--end bg-->
   <!-- Free template distributed by http://freehtml5templates.com -->
  </body>

<script src="js/Detector.js"></script>
<script src="js/webgl-utils.js"></script>
<script src="js/shader.js"></script>
<script src="js/math.js"></script>
<script src="js/iaparser.js"></script>
<script src="js/fparser.js"></script>

<script>

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

// mouse interactions
var mousePos;
var dragStart;
var dragging = false;
var pan = {x:0,y:0};
var curPan = {x:0,y:0};
var zoom = 1.0;

// global variables
var canvas;
var gl;
var WIDTH = 400, HEIGHT = 400;
var curvesShader, texShader, fxaaShader, taubinShader;

// expression constants
var constants = new Set();
    
var grid = {
  src: 0,
  dst: 1,
  w: WIDTH,
  h: HEIGHT,
  dx: 1.0,
  t: [],
  fbo: 0,
  pixels: null,
  swap: function() {
    var tmp = this.src;
    this.src = this.dst;
    this.dst = tmp;
  },
  init: function(W, H) {
    this.w = W;
    this.h = H;
    this.pixels = new Uint8Array(4 * this.w * this.h); // be careful - allocate memory only once

    this.fbo = gl.createFramebuffer();
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);

          for (var i = 0; i < 2; ++i) {
            var texture = gl.createTexture();
      this.t.push(texture);
            
      gl.bindTexture(gl.TEXTURE_2D, texture);

      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.w, this.h, 0,
              gl.RGBA, gl.UNSIGNED_BYTE, null);

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
          gl.TEXTURE_2D, this.t[i], 0);

      checkFB(this.fbo);
      gl.clear(gl.COLOR_BUFFER_BIT);
      }
  },
  enable: function() {
    gl.viewport(0, 0, this.w, this.h);
    
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, 
        gl.TEXTURE_2D, this.t[this.dst], 0);
    
  },
  disable: function(){
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  },
  print: function() {
    console.log("src " + this.src);
    console.log("dst " + this.dst);
    console.log("size " + this.w + "," + this.h); 
    console.log("dx " + this.dx);
    console.log("tex " + this.t[0] + " " + this.t[1]);
         
    gl.viewport(0, 0, this.w, this.h);
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);      
    gl.readPixels(0, 0, this.w, this.h, gl.RGBA, gl.UNSIGNED_BYTE, this.pixels);
    
    var converted = new Float32Array(this.pixels, 0, this.pixels.length/4);
    
    console.log("pixels size " + this.pixels.length);

    console.log("converted size " + converted.length);

    for (var j = 5; j >= 0; --j) {
        var str = "";
        for (var i = (0); i < 5; ++i) {
          str += " " + converted[j*this.w + i];
        }
        console.log(str);
     }
  }
};


var _2dCurves_vs, fxaa_vs, fxaa_fs, _2dCurves_vs, ia_fs, iaFooter_fs, iaHeader_fs, taubin_vs, taubinFooter_fs, taubinHeader_fs, texture_fs, texture_vs;
$.get("/WebGL-Tools/2dCurves/2dCurves.vs", function(data_2dCurves_vs){
  $.get("/WebGL-Tools/2dCurves/fxaa.vs", function(data_fxaa_vs){
    $.get("/WebGL-Tools/2dCurves/fxaa.fs", function(data_fxaa_fs){
      $.get("/WebGL-Tools/2dCurves/ia.fs", function(data_ia_fs){
        $.get("/WebGL-Tools/2dCurves/iaFooter.fs", function(data_iaFooter_fs){
          $.get("/WebGL-Tools/2dCurves/iaHeader.fs", function(data_iaHeader_fs){
            $.get("/WebGL-Tools/2dCurves/taubin.vs", function(data_taubin_vs){
              $.get("/WebGL-Tools/2dCurves/taubinFooter.fs", function(data_taubinFooter_fs){
                $.get("/WebGL-Tools/2dCurves/taubinHeader.fs", function(data_taubinHeader_fs){
                  $.get("/WebGL-Tools/2dCurves/texture.fs", function(data_texture_fs){
                    $.get("/WebGL-Tools/2dCurves/texture.vs", function(data_texture_vs){
                      texture_vs = data_texture_vs; 
                      init();
                      render();
                      });
                      texture_fs = data_texture_fs; });
                      taubinHeader_fs = data_taubinHeader_fs; });
                      taubinFooter_fs = data_taubinFooter_fs; });
                      taubin_vs = data_taubin_vs; });
                      iaHeader_fs = data_iaHeader_fs; });
                      iaFooter_fs = data_iaFooter_fs; });
                      ia_fs = data_ia_fs; });
                      fxaa_fs = data_fxaa_fs; });
                      fxaa_vs = data_fxaa_vs; });
                      _2dCurves_vs = data_2dCurves_vs; });

function updateUniforms(e){
  zoom = document.getElementById('inputZoom').value;
  curvesShader.start(gl);
    curvesShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    curvesShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    curvesShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    curvesShader.setUniform1f(gl, "zoom", zoom);
      constants.forEach(function(value) {
        curvesShader.setUniform1f(gl, value, document.getElementById('input' + value).value);
      });
  curvesShader.stop(gl);

  taubinShader.start(gl);
    taubinShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    taubinShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    taubinShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    taubinShader.setUniform1f(gl, "zoom", zoom);
      constants.forEach(function(value) {
        taubinShader.setUniform1f(gl, value, document.getElementById('input' + value).value);
      });
  taubinShader.stop(gl);

  render();
}

function solve() {
  var fs = iaHeader_fs + "\n";

  constants = IAPARSER.parseConstants(document.getElementById("eText").value);
  constants.forEach(function(value) {
      fs += "uniform float " + value + ";\n";
  });

  $('#constants').remove();

  //console.log(constants.size);
  
  fs += ia_fs + "\n" + 
      IAPARSER.parse(document.getElementById("eText").value) +
      iaFooter_fs;
        
  console.log(fs);
  console.log("CONSTANTS");
  console.log([WIDTH,HEIGHT]);
  console.log("ratio" + [1.0,HEIGHT/WIDTH]);
  console.log("offset" + [curPan.x,curPan.y]);
  console.log("zoom" + zoom);

  curvesShader.loadText(gl, _2dCurves_vs, fs);
  curvesShader.start(gl);
    curvesShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    curvesShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    curvesShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    curvesShader.setUniform1f(gl, "zoom", zoom);
    if(constants.size > 0){
      var div = document.createElement("div");
      div.setAttribute("id", "constants");
      $('#user').prepend(div);

      constants.forEach(function(value) {
        var valueInput = document.createElement("INPUT");
        valueInput.setAttribute("id", "input" + value);
        valueInput.setAttribute("type", "number");
        valueInput.setAttribute("value", "1");
        valueInput.setAttribute("step", "0.0001");
        
        $('<div>').appendTo('#constants');
        $('<label for="input' + value + '"">' + value + '</label>').appendTo('#constants');
        $('#constants').append(valueInput);
        $('</div>').appendTo('#constants');

        $('#' + "input" + value).bind('keyup mouseup', updateUniforms);

        curvesShader.setUniform1f(gl, value, 1.0);
      });
    }
  curvesShader.stop(gl);

  solveFloat();

  render();
}

function solveFloat() {
  var fs =  taubinHeader_fs + "\n";

  constants.forEach(function(value) {
      fs += "uniform float " + value + ";\n";
  });
  
  fs += FPARSER.parse(document.getElementById("eText").value) +
      taubinFooter_fs;
  
  console.log(fs);
  taubinShader.loadText(gl, taubin_vs, fs);
  taubinShader.start(gl);
    taubinShader.setUniform2f(gl, "size", [WIDTH,HEIGHT]);
    taubinShader.setUniform2f(gl, "ratio", [1.0,HEIGHT/WIDTH]);
    taubinShader.setUniform2f(gl, "offset", [curPan.x,curPan.y]);
    taubinShader.setUniform1f(gl, "zoom", zoom);
    if(constants.size > 0){
      constants.forEach(function(value) {
        taubinShader.setUniform1f(gl, value, 1.0);
      });
    }
  taubinShader.stop(gl);
}

function setFunction(e) {
  document.getElementById("eText").value = e;
  solve();
}

function init() {
  // Get A WebGL context
  canvas = document.getElementById("canvas");
    // Make it visually fill the positioned parent
  canvas.style.width ='100%';
  canvas.style.height='100%';
  // ...then set the internal size to match
  canvas.width  = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
  
  HEIGHT = canvas.height;
  WIDTH = canvas.width;
  
  gl = getWebGLContext(canvas);
  if (!gl)
    return;
  $('#inputZoom').bind('keyup mouseup', updateUniforms);
  // MOUSE INTERACTIONS ----------------------------------------------------
  canvas.addEventListener('mousemove', function(evt) {
      if(dragging) {
        mousePos = getMousePos(canvas, evt);
        var offset = {};
        offset.x = ((mouseStart.x - mousePos.x)/WIDTH)*zoom; 
        offset.y = ((mouseStart.y - mousePos.y)/HEIGHT)*zoom; 
        curPan.x = pan.x + offset.x;
        curPan.y = pan.y + offset.y;
        //curvesShader.start(gl);
        //  curvesShader.setUniform2f(gl, "offset", [pan.x + offset.x,pan.y + offset.y]);
        //curvesShader.stop(gl);
        updateUniforms();
        render();
        }
        }, false);

  canvas.addEventListener('mousedown', function(evt) {
      if(!dragging){
      dragging = true;
      mouseStart = getMousePos(canvas, evt);
      }
      }, false);
  
  canvas.addEventListener('mouseup', function(evt) {
      if(dragging){
        pan.x += ((mouseStart.x - mousePos.x)/WIDTH)*zoom; 
        pan.y += ((mouseStart.y - mousePos.y)/HEIGHT)*zoom; 
        curPan.x = pan.x;
        curPan.y = pan.y;
      }
      dragging = false;
      }, false);
  
  canvas.addEventListener('mousewheel', function(evt) {
        var wheel = event.wheelDelta/120;
        zoom += wheel/10;
        updateUniforms();
        //curvesShader.start(gl);
        //curvesShader.setUniform1f(gl, "zoom", zoom);
        //curvesShader.stop(gl);
        render();
      }, false);
  //------------------------------------------------------------------------


  // SHADER PROGRAMS -------------------------------------------------------
  texShader = new SHADER.Shader(gl, texture_vs, texture_fs);
  curvesShader = new SHADER.Shader(gl, texture_vs, texture_fs);
  taubinShader = new SHADER.Shader(gl, texture_vs, texture_fs);
  fxaaShader = new SHADER.Shader(gl, fxaa_vs, fxaa_fs);
  fxaaShader.start(gl);
    fxaaShader.setUniform1f(gl, "FXAA_SPAN_MAX", 8.0);
    fxaaShader.setUniform1f(gl, "FXAA_REDUCE_MUL", 1.0/8.0);
    fxaaShader.setUniform1f(gl, "FXAA_SUBPIX_SHIFT", 1.0/4.0);
    fxaaShader.setUniform1f(gl, "rt_w", WIDTH);
    fxaaShader.setUniform1f(gl, "rt_h", HEIGHT);
  fxaaShader.stop(gl);
  //------------------------------------------------------------------------
  
  // TEXTURE BUFFER DATA ---------------------------------------------------
  var positionLocation = texShader.getLocation(gl, "vpos");
  var positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1.0, -1.0,
        3.0, -1.0,
        -1.0, 3.0]), gl.STATIC_DRAW);
  //------------------------------------------------------------------------
  
  grid.init(WIDTH, HEIGHT);

  solve();
}

function computeCurves() {
  grid.enable();
  curvesShader.start(gl);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
  curvesShader.stop(gl);
  grid.disable();
}

function render() {
  computeCurves();

  gl.viewport(0, 0, WIDTH, HEIGHT);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, grid.t[grid.dst]);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  var radios = document.getElementsByName('anti-aliasing');
  var selected = "none";
  for (var i = 0, length = radios.length; i < length; i++) {
    if (radios[i].checked) {
        selected = radios[i].value;
        break;
    }
  }
  
  if(selected == "fxaa"){
    fxaaShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    fxaaShader.stop(gl);
  }
  else if(selected == "taubin"){
    taubinShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    taubinShader.stop(gl);
    
   /* grid.enable();
    taubinShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    taubinShader.stop(gl);
    grid.disable();
    grid.swap();
    grid.print();*/
  }
  else {
    texShader.start(gl);
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    texShader.stop(gl);
  }
}

function checkFB(framebuffer) {
  if (!gl.isFramebuffer(framebuffer))
    throw("Invalid framebuffer");
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
      switch (status) {
    case gl.FRAMEBUFFER_COMPLETE: break;
    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
      throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
      break;
    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
            break;
    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
            break;
    case gl.FRAMEBUFFER_UNSUPPORTED:
            throw("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
            break;
    default: throw("Incomplete framebuffer: " + status);
  }
}

function getMousePos(canvas, evt) {
  var rect = canvas.getBoundingClientRect();
  return {
    x: Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*canvas.width),
    y: Math.round((evt.clientY-rect.bottom)/(-rect.bottom+rect.top)*canvas.height)
  };
}

</script>
</html>
